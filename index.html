<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>„Éë„É©„Ç∑„É•„Éº„Éà„Éª„Éú„Éº„É§</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* ‰∏äË©∞„ÇÅ„Å´„Åô„Çã */
            width: 100%;
            height: 100vh; /* ÁîªÈù¢„ÅÑ„Å£„Å±„ÅÑ„Å´Âõ∫ÂÆö */
            height: 100dvh; /* „É¢„Éê„Ç§„É´„Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç¢„Éâ„É¨„Çπ„Éê„ÉºÂØæÁ≠ñ */
            padding: 10px;
            overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´Á¶ÅÊ≠¢ */
            touch-action: none; /* „Çπ„ÇØ„É≠„Éº„É´„ÇÑ„Ç∫„Éº„É†„ÅÆ„Ç∏„Çß„Çπ„ÉÅ„É£„ÇíÁÑ°ÂäπÂåñ */
            user-select: none; /* Èï∑Êäº„Åó„Å´„Çà„Çã„ÉÜ„Ç≠„Çπ„ÉàÈÅ∏ÊäûÁ¶ÅÊ≠¢ */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* iOSÈï∑Êäº„Åó„É°„Éã„É•„ÉºÁ¶ÅÊ≠¢ */
        }
        
        h1 {
            color: #2C3E50;
            font-size: clamp(18px, 4vw, 24px); /* Â∞ë„ÅóÂ∞è„Åï„Åè„Åó„Å¶ÁîªÈù¢„ÇíÂ∫É„Åè‰Ωø„ÅÜ */
            margin: 5px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .score-board {
            display: flex;
            gap: 15px;
            margin-bottom: 5px;
            font-size: clamp(12px, 3vw, 16px);
            color: #2C3E50;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .score-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 12px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .game-container {
            position: relative;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            flex-grow: 1; /* ÂèØËÉΩ„Å™Èôê„ÇäÂ§ß„Åç„Åè */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 70%, #4682B4 100%);
            border: 2px solid #2C3E50;
            border-radius: 10px;
            display: block;
            /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çµ„Ç§„Ç∫Ë™øÊï¥: Á∏¶Ê®™ÊØî„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§„Ç≥„É≥„ÉÜ„Éä„Å´Âèé„ÇÅ„Çã */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; 
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            width: 85%;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-size: 22px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .modal-msg {
            font-size: 15px;
            color: #555;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .modal-btn {
            background: #2ECC71;
            color: white;
            border: none;
            padding: 12px 0;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            box-shadow: 0 3px 0 #27AE60;
        }
        .modal-btn:active {
            transform: translateY(3px);
            box-shadow: none;
        }
        .btn-retry { background: #E74C3C; box-shadow: 0 3px 0 #C0392B; }
        
        .wind-indicator {
            font-size: 16px;
            color: #2C3E50;
            font-weight: bold;
            min-height: 1.5em;
            text-align: center;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        .wind-bar {
            display: inline-block;
            font-family: monospace;
            letter-spacing: -2px;
        }

        /* --- „Ç≥„É≥„Éà„É≠„Éº„É©„Éº„Ç®„É™„Ç¢„ÅÆ„Éá„Ç∂„Ç§„É≥ --- */
        .controller-area {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 10px 20px 20px 20px; /* ‰∏ãÈÉ®„Å´‰ΩôÁôΩ */
            /* iOS„Çª„Éº„Éï„Ç®„É™„Ç¢ÂØæÂøúÔºàiPhone X‰ª•Èôç„ÅÆ‰∏ãÈÉ®„Éê„ÉºÂõûÈÅøÔºâ */
            padding-bottom: calc(20px + env(safe-area-inset-bottom)); 
            gap: 20px;
            flex-shrink: 0;
        }

        /* Â∑¶ÂÅ¥„ÅÆÁßªÂãï„Éú„Çø„É≥Áæ§ */
        .d-pad {
            display: flex;
            gap: 10px;
        }

        button.control-btn {
            background: linear-gradient(to bottom, #3498DB, #2980B9);
            color: white;
            border: none;
            width: 70px;
            height: 60px; /* Êäº„Åó„ÇÑ„Åô„ÅÑ„Çµ„Ç§„Ç∫ */
            font-size: 24px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 0 #1A5276;
            transition: transform 0.1s;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        button.control-btn:active {
            transform: translateY(4px);
            box-shadow: none;
            background: linear-gradient(to bottom, #2980B9, #21618C);
        }

        /* Âè≥ÂÅ¥„ÅÆA„Éú„Çø„É≥ */
        .action-btn-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #actionBtn {
            background: radial-gradient(circle at 30% 30%, #ff7f50, #ff4500);
            color: white;
            border: 4px solid #fff;
            width: 75px;
            height: 75px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: bold;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            touch-action: manipulation;
        }
        #actionBtn:active {
            transform: scale(0.95);
            background: radial-gradient(circle at 30% 30%, #ff6347, #cd3700);
        }

    </style>
</head>
<body>
    <h1>ü™Ç „Éë„É©„Ç∑„É•„Éº„ÉàÁùÄÈô∏„Ç≤„Éº„É†</h1>
    <div class="score-board">
        <div class="score-item">„Çπ„ÉÜ„Éº„Ç∏: <span id="stage">1</span> / 10</div>
        <div class="score-item">ÊúÄÈ´òË®òÈå≤: <span id="best">0</span></div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div id="gameOverlay">
            <div class="modal-content">
                <div id="modalTitle" class="modal-title"></div>
                <div id="modalMsg" class="modal-msg"></div>
                <button id="modalBtn" class="modal-btn">Ê¨°„Å∏</button>
            </div>
        </div>
    </div>

    <div class="wind-indicator" id="windIndicator">È¢®: Lv.0</div>
    
    <div class="controller-area">
        <div class="d-pad">
            <button id="leftBtn" class="control-btn">‚¨ÖÔ∏è</button>
            <button id="rightBtn" class="control-btn">‚û°Ô∏è</button>
        </div>
        
        <div class="action-btn-container">
            <button id="actionBtn">A</button>
        </div>
    </div>

    <audio id="bgm" src="audio/backgroundmugic.mp3" loop preload="auto"></audio>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // --- iOSÁî®„ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÊã°Â§ßÈò≤Ê≠¢ ---
        document.addEventListener('dblclick', function(event) {
            event.preventDefault();
        }, { passive: false });

        // „Éî„É≥„ÉÅ„Ç∫„Éº„É†Èò≤Ê≠¢
        document.addEventListener('touchmove', function(event) {
            if (event.scale !== 1) { 
                event.preventDefault(); 
            }
        }, { passive: false });
        
        // --- Web Audio API (SEÁîüÊàêÁî®) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSE(type) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'float') {
                // „Åµ„Çè„Å£„Å®Èü≥
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);

            } else if (type === 'hit') {
                // Ë°ùÁ™ÅÈü≥
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);

            } else if (type === 'success') {
                // ÊàêÂäüÈü≥
                const notes = [523.25, 659.25, 783.99]; // C, E, G
                notes.forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'triangle';
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.frequency.value = freq;
                    const time = now + i * 0.1;
                    g.gain.setValueAtTime(0.2, time);
                    g.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                    o.start(time);
                    o.stop(time + 0.4);
                });
            }
        }

        // --- BGMË®≠ÂÆö ---
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.8; 
        let isBgmPlaying = false;

        function startBgm() {
            if (!isBgmPlaying) {
                bgm.play().then(() => {
                    isBgmPlaying = true;
                }).catch(e => {
                    console.log("BGM play waiting for interaction");
                });
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- SVGÁîªÂÉè„ÅÆÂÆöÁæ© ---
        const parachuteSVG = `
            <g transform="translate(250, 200)">
                <path d="M-150,0 A150,150 0 0,1 150,0" fill="none" stroke="#333" stroke-width="5"/>
                <path d="M-150,0 A150,150 0 0,1 -75,-129.9 L-50,-86.6 A100,100 0 0,0 -100,0 Z" fill="#E74C3C" stroke="#333" stroke-width="3"/>
                <path d="M-75,-129.9 A150,150 0 0,1 0,-150 L0,-100 A100,100 0 0,0 -50,-86.6 Z" fill="#E67E22" stroke="#333" stroke-width="3"/>
                <path d="M0,-150 A150,150 0 0,1 75,-129.9 L50,-86.6 A100,100 0 0,0 0,-100 Z" fill="#F1C40F" stroke="#333" stroke-width="3"/>
                <path d="M75,-129.9 A150,150 0 0,1 150,0 L100,0 A100,100 0 0,0 50,-86.6 Z" fill="#2ECC71" stroke="#333" stroke-width="3"/>
                <path d="M-100,0 A100,100 0 0,1 100,0" fill="#3498DB" stroke="#333" stroke-width="3"/>
            </g>
            <g stroke="#333" stroke-width="3">
                <line x1="100" y1="200" x2="200" y2="330" /> <line x1="400" y1="200" x2="300" y2="330" />
                <line x1="150" y1="200" x2="210" y2="330" /> <line x1="350" y1="200" x2="290" y2="330" />
                <line x1="200" y1="200" x2="220" y2="330" /> <line x1="300" y1="200" x2="280" y2="330" />
            </g>`;

        const svgNormalStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            ${parachuteSVG}
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="0" rx="50" ry="60" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <path d="M-30,-50 A40,40 0 0,1 30,-50" fill="#F1C40F" stroke="#333" stroke-width="3"/> 
                <g fill="#333"> 
                    <circle cx="-15" cy="-20" r="5"/> <circle cx="15" cy="-20" r="5"/>
                    <path d="M-25,-35 Q-15,-30 -5,-35" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M5,-35 Q15,-30 25,-35" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M-15,-5 Q0,-15 15,-5" fill="none" stroke="#333" stroke-width="2"/>
                </g>
                <path d="M-50,0 Q-70,-20 -60,-40" fill="none" stroke="#333" stroke-width="4"/>
                <path d="M50,0 Q70,-20 60,-40" fill="none" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        const svgPanicStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            ${parachuteSVG}
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="0" rx="50" ry="60" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <path d="M-30,-50 A40,40 0 0,1 30,-50" fill="#F1C40F" stroke="#333" stroke-width="3"/> 
                <g stroke="#333" stroke-width="3" fill="none">
                    <path d="M-25,-25 L-15,-20 L-25,-15"/>
                    <path d="M25,-25 L15,-20 L25,-15"/>
                    <circle cx="0" cy="10" r="10" fill="#333"/>
                    <path d="M35,-40 Q40,-50 45,-35" stroke="#3498DB" fill="#E0F7FA"/>
                    <path d="M-35,-40 Q-40,-50 -45,-35" stroke="#3498DB" fill="#E0F7FA"/>
                </g>
                <path d="M-45,-10 L-70,-40" stroke="#333" stroke-width="4"/>
                <path d="M45,-10 L70,-40" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        const svgLandedStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            <g transform="translate(250, 410) scale(1, 0.3)">
                <path d="M-150,0 A150,150 0 0,1 150,0 Z" fill="#BDC3C7" stroke="#333" stroke-width="5"/>
            </g>
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="10" rx="50" ry="50" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <g fill="#333"> 
                    <path d="M-20,-20 Q-15,-25 -10,-20" stroke="#333" stroke-width="3" fill="none"/>
                    <path d="M10,-20 Q15,-25 20,-20" stroke="#333" stroke-width="3" fill="none"/>
                    <path d="M-10,-5 Q0,10 10,-5" stroke="#333" stroke-width="2" fill="none"/>
                    <path d="M-50,20 L-70,0" stroke="#333" stroke-width="4"/>
                    <path d="M50,20 L70,0" stroke="#333" stroke-width="4"/>
                </g>
            </g>
        </svg>`;

        const svgWaterStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            <g transform="translate(250, 380)">
                <path d="M-50,0 A50,60 0 0,1 50,0 L50,20 L-50,20 Z" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <g fill="#333"> 
                    <circle cx="-15" cy="-20" r="7" fill="#fff"/> <circle cx="-15" cy="-20" r="2"/>
                    <circle cx="15" cy="-20" r="7" fill="#fff"/> <circle cx="15" cy="-20" r="2"/>
                    <path d="M-10,0 Q0,-5 10,0 Q5,5 -5,5 Z" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M-20,-15 L-18,-12 M20,-15 L18,-12" stroke="#3498DB" stroke-width="2"/>
                </g>
                <path d="M-50,0 Q-70,-30 -80,-10" fill="none" stroke="#333" stroke-width="4"/>
                <path d="M50,0 Q70,-30 80,-10" fill="none" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        function createImg(svgStr) {
            const img = new Image();
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgStr);
            return img;
        }

        const imgNormal = createImg(svgNormalStr);
        const imgPanic = createImg(svgPanicStr);
        const imgLanded = createImg(svgLandedStr);
        const imgWater = createImg(svgWaterStr);
        
        let sharkLoaded = false;
        const imgShark = new Image();
        imgShark.onload = function() { sharkLoaded = true; };
        imgShark.onerror = function() { sharkLoaded = false; };
        imgShark.src = 'shark.png'; 

        let karasuLoaded = false;
        const imgKarasu = new Image();
        imgKarasu.onload = function() { karasuLoaded = true; };
        imgKarasu.onerror = function() { karasuLoaded = false; };
        imgKarasu.src = 'karasu.png';

        // --- „Ç≤„Éº„É†ÂÆöÊï∞ ---
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 600;
        const CANVAS_ASPECT = CANVAS_WIDTH / CANVAS_HEIGHT;
        
        // „Éó„É¨„Ç§„É§„ÉºÂÆöÊï∞
        const PLAYER_START_X = 200;
        const PLAYER_START_Y = 50;
        const PLAYER_RADIUS = 30;
        const PLAYER_SIZE = 100;
        const PLAYER_JUMP_POWER = -1.65;
        const PLAYER_BOUNDARY_MARGIN = 15;
        const PLAYER_SAFE_MARGIN = 15;
        const PLAYER_PANIC_MARGIN = 20;
        const PLAYER_NEAR_GROUND_Y = 400;
        
        // È¢®„ÅÆÂÆöÊï∞
        const WIND_STRENGTH_LEFT = -0.3;
        const WIND_STRENGTH_RIGHT = 0.3;
        const WIND_MAX = 0.6;
        const WIND_THRESHOLD = 0.05;
        const WIND_WINDY_THRESHOLD = 0.1;
        const WIND_BASE_STRENGTH = 0.1;
        const WIND_STAGE_INCREMENT = 0.01;
        const WIND_CHANGE_INTERVAL = 60;
        const WIND_SMOOTH_FACTOR = 0.05;
        
        // Áâ©ÁêÜÂÆöÊï∞
        const BASE_GRAVITY_SPEED = 0.85;
        const GRAVITY_RECOVERY = 0.05;
        const FRICTION = 0.95;
        
        // Ë°ùÁ™ÅÂà§ÂÆöÂÆöÊï∞
        const KARASU_COLLISION_DISTANCE = 55;
        const GROUND_LEVEL_OFFSET = 15;
        const LANDING_Y_OFFSET = 10;
        
        // „Ç´„É©„ÇπÂÆöÊï∞
        const KARASU_WIDTH = 120;
        const KARASU_HEIGHT = 90;
        const KARASU_SPAWN_STAGE = 3;
        const KARASU_SPAWN_OFFSET = 100;
        const KARASU_SPAWN_Y_MIN = 50;
        const KARASU_SPAWN_Y_RANGE = 300;
        
        // ÁùÄÈô∏„Ç®„É™„Ç¢ÂÆöÊï∞
        const LANDING_BASE_WIDTH = 120;
        const LANDING_WIDTH_REDUCTION = 3;
        const LANDING_MIN_WIDTH = 20;
        const LANDING_CENTER_X = 200;
        const LANDING_Y = 550;
        
        // Èõ≤„ÅÆÂÆöÊï∞
        const CLOUD_COUNT = 5;
        const CLOUD_SIZE_MIN = 20;
        const CLOUD_SIZE_RANGE = 30;
        const CLOUD_SPEED_MIN = 0.3;
        const CLOUD_SPEED_RANGE = 0.5;
        const CLOUD_SPAWN_Y_MAX = 400;
        
        // „Çµ„É°„ÅÆÂÆöÊï∞
        const SHARK_WIDTH = 300;
        const SHARK_HEIGHT = 175;
        const SHARK_Y_OFFSET = 80;
        const SHARK_FLOAT_AMPLITUDE = 8;
        const SHARK_FLOAT_PERIOD = 800;
        
        // „Ç≤„Éº„É†Ë®≠ÂÆöÂÆöÊï∞
        const MAX_STAGE = 10;
        const RESULT_DELAY = 500;
        const RESIZE_DELAY = 100;
        
        // --- „ÇØ„É©„ÇπÂÆöÁæ© ---
        
        // „Éó„É¨„Ç§„É§„Éº„ÇØ„É©„Çπ
        class Player {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.x = PLAYER_START_X;
                this.y = PLAYER_START_Y;
                this.vx = 0;
                this.vy = BASE_GRAVITY_SPEED;
                this.state = 'falling';
                this.mood = 'normal';
                this.radius = PLAYER_RADIUS;
            }
            
            jump() {
                if (this.state === 'falling') {
                    this.vy = PLAYER_JUMP_POWER;
                }
            }
            
            update(windForce, isGameOver, landing) {
                if (isGameOver) {
                    // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÊôÇ„ÅÆ‰ΩçÁΩÆÂõ∫ÂÆö
                    if (this.state === 'landed') {
                        this.y = landing.y - LANDING_Y_OFFSET;
                        this.vx = 0;
                    }
                    if (this.state === 'water') {
                        this.y = landing.y;
                        this.vx = 0;
                    }
                    return;
                }
                
                // ÈáçÂäõ„ÅÆÂõûÂæ©
                if (this.vy < BASE_GRAVITY_SPEED) {
                    this.vy += GRAVITY_RECOVERY;
                } else {
                    this.vy = BASE_GRAVITY_SPEED;
                }

                // È¢®„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Çã
                this.vx += windForce;
                this.vx *= FRICTION;
                this.x += this.vx;
                this.y += this.vy;
                
                // Â∑¶Âè≥„ÅÆÂ¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØ
                if (this.x < PLAYER_BOUNDARY_MARGIN) { 
                    this.x = PLAYER_BOUNDARY_MARGIN; 
                    this.vx = 0; 
                }
                if (this.x > canvas.width - PLAYER_BOUNDARY_MARGIN) { 
                    this.x = canvas.width - PLAYER_BOUNDARY_MARGIN; 
                    this.vx = 0; 
                }
            }
            
            checkLanding(landing) {
                // Êµ∑„Å´ËêΩ„Å°„ÅüÂ†¥Âêà
                if (this.y >= landing.y) {
                    this.state = 'water';
                    this.y = landing.y;
                    this.vx = 0; 
                    this.vy = 0;
                    return 'water';
                }
                
                // ÁùÄÈô∏Âà§ÂÆö
                const groundLevel = landing.y - GROUND_LEVEL_OFFSET; 
                if (this.y >= groundLevel) {
                    const safeMargin = PLAYER_SAFE_MARGIN; 
                    const isSafe = (this.x >= landing.start - safeMargin && this.x <= landing.end + safeMargin);
                    if (isSafe) {
                        this.state = 'landed';
                        this.y = landing.y - LANDING_Y_OFFSET;
                        this.vx = 0; 
                        this.vy = 0;
                        return 'landed';
                    }
                }
                return null;
            }
        }
        
        // È¢®„ÇØ„É©„Çπ
        class Wind {
            constructor() {
                this.playerWind = 0; // „Éó„É¨„Ç§„É§„Éº„ÅåÊìç‰Ωú„Åô„ÇãÈ¢®
                this.naturalWind = 0; // Ëá™ÁÑ∂„ÅÆÈ¢®
                this.targetNaturalWind = 0; // Ëá™ÁÑ∂„ÅÆÈ¢®„ÅÆÁõÆÊ®ôÂÄ§
                this.timer = 0;
            }
            
            reset() {
                this.playerWind = 0;
                this.naturalWind = 0;
                this.targetNaturalWind = 0;
                this.timer = 0;
            }
            
            setPlayerWind(value) {
                this.playerWind = value;
            }
            
            update(stage) {
                this.timer++;
                if (this.timer > WIND_CHANGE_INTERVAL) {
                    this.timer = 0;
                    const windStrength = WIND_BASE_STRENGTH + (stage - 1) * WIND_STAGE_INCREMENT;
                    this.targetNaturalWind = (Math.random() - 0.5) * windStrength;
                }
                this.naturalWind += (this.targetNaturalWind - this.naturalWind) * WIND_SMOOTH_FACTOR;
            }
            
            getTotalWind() {
                return this.playerWind + this.naturalWind;
            }
            
            getWindLevel() {
                const windMag = Math.abs(this.getTotalWind());
                let level = Math.floor((windMag / WIND_MAX) * 10);
                if (level > 10) level = 10;
                if (windMag > 0 && level === 0) level = 1;
                if (windMag < WIND_THRESHOLD) level = 0;
                return level;
            }
        }
        
        // Èõ≤„ÇØ„É©„Çπ
        class Cloud {
            constructor() {
                this.x = Math.random() * CANVAS_WIDTH;
                this.y = Math.random() * CLOUD_SPAWN_Y_MAX;
                this.size = CLOUD_SIZE_MIN + Math.random() * CLOUD_SIZE_RANGE;
                this.speed = CLOUD_SPEED_MIN + Math.random() * CLOUD_SPEED_RANGE;
            }
            
            update() {
                this.x += this.speed;
                if (this.x > canvas.width + this.size) {
                    this.x = -this.size;
                    this.y = Math.random() * CLOUD_SPAWN_Y_MAX;
                }
            }
            
            draw(ctx) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.6, this.y, this.size * 0.8, 0, Math.PI * 2);
                ctx.arc(this.x - this.size * 0.6, this.y, this.size * 0.8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // „Ç´„É©„Çπ„ÇØ„É©„Çπ
        class Karasu {
            constructor() {
                const startLeft = Math.random() < 0.5;
                const speedBase = (1.5 + Math.random() * 2.0) * 0.2;
                
                this.x = startLeft ? -KARASU_SPAWN_OFFSET - Math.random() * KARASU_SPAWN_OFFSET : canvas.width + KARASU_SPAWN_OFFSET + Math.random() * KARASU_SPAWN_OFFSET;
                this.y = KARASU_SPAWN_Y_MIN + Math.random() * KARASU_SPAWN_Y_RANGE;
                this.vx = startLeft ? speedBase : -speedBase;
                this.vyBase = Math.random() * 0.5;
                this.vyFreq = 0.05 + Math.random() * 0.05;
                this.timer = Math.random() * 100;
                this.width = KARASU_WIDTH;
                this.height = KARASU_HEIGHT;
                this.motionType = Math.floor(Math.random() * 3);
            }
            
            update() {
                this.timer += 0.1;
                this.x += this.vx;
                
                // Âãï„Åç„ÅÆ„Éë„Çø„Éº„É≥
                if (this.motionType === 0) {
                    this.y += Math.sin(this.timer) * 0.5;
                } else if (this.motionType === 1) {
                    this.y += Math.sin(this.timer * 0.5) * 2.0;
                } else {
                    this.y += Math.sin(this.timer * 3.0) * 1.5;
                }

                // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„ÇâÂèçÂØæÂÅ¥„Åã„ÇâÂÜçÂá∫Áèæ
                if (this.vx > 0 && this.x > canvas.width + KARASU_SPAWN_OFFSET) {
                    this.x = -KARASU_SPAWN_OFFSET;
                    this.y = KARASU_SPAWN_Y_MIN + Math.random() * KARASU_SPAWN_Y_RANGE;
                } else if (this.vx < 0 && this.x < -KARASU_SPAWN_OFFSET) {
                    this.x = canvas.width + KARASU_SPAWN_OFFSET;
                    this.y = KARASU_SPAWN_Y_MIN + Math.random() * KARASU_SPAWN_Y_RANGE;
                }
            }
            
            checkCollision(player) {
                const kCenterX = this.x + this.width / 2;
                const kCenterY = this.y + this.height / 2;
                const dx = player.x - kCenterX;
                const dy = player.y - kCenterY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < KARASU_COLLISION_DISTANCE;
            }
            
            draw(ctx, imgKarasu, karasuLoaded) {
                if (karasuLoaded) {
                    ctx.save();
                    ctx.translate(this.x + this.width/2, this.y + this.height/2);
                    if (this.vx < 0) {
                        ctx.scale(-1, 1);
                    }
                    ctx.drawImage(imgKarasu, -this.width/2, -this.height/2, this.width, this.height);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'black';
                    ctx.font = '60px Arial';
                    ctx.fillText('ü¶Ö', this.x, this.y + 40);
                }
            }
        }
        
        // ÁùÄÈô∏„Ç®„É™„Ç¢„ÇØ„É©„Çπ
        class Landing {
            constructor() {
                this.y = LANDING_Y;
                this.start = 140;
                this.end = 260;
            }
            
            initForStage(stage) {
                const reduction = (stage - 1) * LANDING_WIDTH_REDUCTION;
                const newWidth = Math.max(LANDING_MIN_WIDTH, LANDING_BASE_WIDTH - reduction);
                this.start = LANDING_CENTER_X - newWidth / 2;
                this.end = LANDING_CENTER_X + newWidth / 2;
            }
        }
        
        // --- „Ç≤„Éº„É†Â§âÊï∞ ---
        
        function resizeCanvas() {
            // „Ç≤„Éº„É†„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË™øÊï¥
            const container = document.querySelector('.game-container');
            const aspect = CANVAS_ASPECT;
            
            // „Ç≥„É≥„ÉÜ„Éä„ÅÆÂπÖ„Å®È´ò„Åï„Åã„ÇâÊúÄÈÅ©„Å™„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
            let w = container.clientWidth;
            let h = container.clientHeight;
            
            if (w / h > aspect) {
                // Ê®™Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÄÅÈ´ò„Åï„Å´Âêà„Çè„Åõ„Çã
                w = h * aspect;
            } else {
                // Á∏¶Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÄÅÂπÖ„Å´Âêà„Çè„Åõ„Çã
                h = w / aspect;
            }
            
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
        }
        window.addEventListener('resize', resizeCanvas);
        // ÂàùÊúüÂåñÊôÇ„Å´„ÇÇÂëº„Å∂ÔºàDOMÊèèÁîªÂæÖ„Å°Ôºâ
        setTimeout(resizeCanvas, RESIZE_DELAY);
        
        let currentStage = 1;
        let bestStage = 0;
        let isGameOver = false;

        // „ÇØ„É©„Çπ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÅÆ‰ΩúÊàê
        const player = new Player();
        const wind = new Wind();
        const landing = new Landing();
        let clouds = [];
        let karasus = [];
        
        function initClouds() {
            clouds = [];
            for (let i = 0; i < CLOUD_COUNT; i++) {
                clouds.push(new Cloud());
            }
        }

        function initKarasus(stage) {
            karasus = [];
            if (stage < KARASU_SPAWN_STAGE) return; 

            const count = (stage - 2) * 2;
            for (let i = 0; i < count; i++) {
                karasus.push(new Karasu());
            }
        }
        
        initClouds();
        
        const overlay = document.getElementById('gameOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMsg = document.getElementById('modalMsg');
        const modalBtn = document.getElementById('modalBtn');

        function hideOverlay() {
            overlay.style.display = 'none';
        }

        function showResult(type) {
            overlay.style.display = 'flex';
            modalBtn.className = 'modal-btn';

            if (type === 'success' && currentStage >= MAX_STAGE) {
                type = 'gameclear';
            }

            if (type === 'success') {
                playSE('success'); 
                modalTitle.textContent = `„Çπ„ÉÜ„Éº„Ç∏ ${currentStage} „ÇØ„É™„Ç¢ÔºÅüéâ`;
                modalTitle.style.color = '#2ECC71';
                modalMsg.textContent = '„ÅäË¶ã‰∫ã„Åß„ÅôÔºÅ\nÊ¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏ÈÄ≤„Åø„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = 'Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏';
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(currentStage + 1);
                    gameLoop();
                };
            } else if (type === 'gameclear') {
                playSE('success'); 
                modalTitle.textContent = `ÂÖ®„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢ÔºÅüéä`;
                modalTitle.style.color = '#F1C40F';
                modalMsg.textContent = '„ÅÇ„Å™„Åü„ÅØÊúÄÈ´ò„ÅÆ„Éë„Ç§„É≠„ÉÉ„Éà„Åß„ÅôÔºÅ\nÊúÄÂàù„Åã„ÇâÈÅä„Å≥„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = '„ÅØ„Åò„ÇÅ„Åã„Çâ';
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(1);
                    gameLoop();
                };
            } else {
                playSE('hit'); 
                modalTitle.textContent = `Â§±Êïó... üò±`;
                modalTitle.style.color = '#E74C3C';
                modalMsg.textContent = 'Ë°ùÁ™Å„Åó„Å¶„Åó„Åæ„ÅÑ„Åæ„Åó„Åü...\n„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åó„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = '„É™„Éà„É©„Ç§';
                modalBtn.classList.add('btn-retry');
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(currentStage);
                    gameLoop();
                };
            }
        }

        function initStage(stage) {
            currentStage = stage;
            document.getElementById('stage').textContent = stage;
            hideOverlay();
            
            // „Éó„É¨„Ç§„É§„Éº„Å®È¢®„Çí„É™„Çª„ÉÉ„Éà
            player.reset();
            wind.reset();
            
            // ÁùÄÈô∏„Ç®„É™„Ç¢„ÇíÂàùÊúüÂåñ
            landing.initForStage(stage);
            
            isGameOver = false;
            
            initClouds();
            initKarasus(stage); 
            startBgm(); 
            resizeCanvas(); // „É™„Éà„É©„Ç§ÊôÇ„ÇÇ„Çµ„Ç§„Ç∫Á¢∫Ë™ç
        }
        
        // drawCloudÈñ¢Êï∞„ÅØÂâäÈô§ÔºàCloud„ÇØ„É©„Çπ„ÅÆdraw„É°„ÇΩ„ÉÉ„Éâ„Çí‰ΩøÁî®Ôºâ
        
        function drawSea() {
            ctx.fillStyle = '#1E90FF';
            ctx.fillRect(0, landing.y, canvas.width, canvas.height - landing.y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                for (let x = 0; x <= canvas.width; x += 20) {
                    const y = landing.y + 10 + i * 15 + Math.sin(x * 0.05 + Date.now() * 0.003) * 5;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }
        
        function drawLanding() {
            const width = landing.end - landing.start;
            const centerX = (landing.start + landing.end) / 2;
            const islandHeight = 30;

            ctx.fillStyle = '#E5C687';
            ctx.beginPath();
            ctx.ellipse(centerX, landing.y, width / 2 + 10, islandHeight, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#D4B06F';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#2ECC71';
            ctx.beginPath();
            ctx.ellipse(centerX, landing.y - 2, width / 2, islandHeight / 1.5, 0, Math.PI, 0); 
            ctx.fill();

            if (width > 30) {
                const treeX = centerX + width / 4;
                const treeY = landing.y - 5;
                ctx.strokeStyle = '#8D6E63';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(treeX, treeY);
                ctx.quadraticCurveTo(treeX + 5, treeY - 15, treeX - 5, treeY - 30);
                ctx.stroke();

                ctx.fillStyle = '#228B22';
                for(let i=0; i<3; i++) {
                    ctx.beginPath();
                    const angle = (i * 120) * Math.PI / 180;
                    const lx = treeX - 5 + Math.cos(angle) * 15;
                    const ly = treeY - 30 + Math.sin(angle) * 10;
                    ctx.ellipse(lx, ly, 8, 4, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawSharks() {
            const baseYPos = landing.y - SHARK_Y_OFFSET;
            const sharkFloatAmount = Math.sin(Date.now() / SHARK_FLOAT_PERIOD) * SHARK_FLOAT_AMPLITUDE;
            const yPos = baseYPos + sharkFloatAmount;
            const useImage = sharkLoaded;

            const leftSharkCenterX = landing.start / 2; 
            const leftSharkDrawX = leftSharkCenterX - (SHARK_WIDTH / 2);

            if (useImage) {
                ctx.drawImage(imgShark, leftSharkDrawX, yPos, SHARK_WIDTH, SHARK_HEIGHT);
            } else {
                ctx.font = '200px Arial';
                ctx.fillText('ü¶à', leftSharkCenterX - 100, yPos + 150);
            }
            
            const rightSharkCenterX = (landing.end + canvas.width) / 2;
            
            if (useImage) {
                ctx.save();
                ctx.translate(rightSharkCenterX, yPos);
                ctx.scale(-1, 1);
                ctx.drawImage(imgShark, -SHARK_WIDTH / 2, 0, SHARK_WIDTH, SHARK_HEIGHT);
                ctx.restore();
            } else {
                ctx.font = '200px Arial';
                ctx.fillText('ü¶à', rightSharkCenterX - 100, yPos + 150);
            }
        }
        
        function updateAndDrawKarasus() {
            karasus.forEach(karasu => {
                if (!isGameOver) {
                    karasu.update();
                    
                    // Ë°ùÁ™ÅÂà§ÂÆö
                    if (karasu.checkCollision(player)) {
                        isGameOver = true;
                        player.state = 'falling'; 
                        setTimeout(() => { showResult('fail'); }, RESULT_DELAY);
                    }
                }
                
                // ÊèèÁîª
                karasu.draw(ctx, imgKarasu, karasuLoaded);
            });
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            const size = PLAYER_SIZE;
            
            if (player.state === 'falling') {
                const sway = Math.sin(Date.now() / 300) * 0.05;
                ctx.rotate(sway);

                const isWindy = Math.abs(wind.getTotalWind()) > WIND_WINDY_THRESHOLD;
                const isNearGround = player.y > PLAYER_NEAR_GROUND_Y;
                const safeMargin = PLAYER_PANIC_MARGIN; 
                const isSafe = player.x >= landing.start - safeMargin && player.x <= landing.end + safeMargin;
                
                let currentImg = imgNormal;
                if (isWindy || (isNearGround && !isSafe)) {
                    currentImg = imgPanic; 
                    const panicShake = Math.sin(Date.now() / 50) * 0.05;
                    ctx.rotate(panicShake);
                }
                ctx.drawImage(currentImg, -size/2, -size/2 - 20, size, size);

            } else if (player.state === 'water') {
                const bob = Math.sin(Date.now() / 200) * 3;
                ctx.translate(0, bob);
                ctx.drawImage(imgWater, -size/2, -size/2 + 20, size, size);

            } else if (player.state === 'landed') {
                ctx.drawImage(imgLanded, -size/2, -size/2 + 10, size, size);
            }
            
            ctx.restore();
        }
        
        function updateWindIndicator() {
            const windIndicator = document.getElementById('windIndicator');
            const totalWind = wind.getTotalWind();
            const level = wind.getWindLevel();

            let text = "";
            let color = "#2C3E50";

            if (level === 0) {
                text = "È¢®: ÁÑ°È¢® (Lv.0)";
            } else {
                const arrow = totalWind < 0 ? "‚óÄ" : "‚ñ∂";
                const bars = arrow.repeat(level);
                if (totalWind < 0) {
                    text = `È¢®: <span class="wind-bar">${bars}</span> Lv.${level}`;
                    color = "#3498DB";
                } else {
                    text = `È¢®: Lv.${level} <span class="wind-bar">${bars}</span>`;
                    color = "#E67E22";
                }
            }
            windIndicator.innerHTML = text;
            windIndicator.style.color = color;
        }
        
        // A„Éú„Çø„É≥„Ç¢„ÇØ„Ç∑„Éß„É≥
        function doAction() {
            if (!isGameOver && player.state === 'falling') {
                player.jump();
                playSE('float'); 
                startBgm();
            }
        }

        // --- „Ç≤„Éº„É†„É´„Éº„Éó„ÅÆÊõ¥Êñ∞Âá¶ÁêÜÔºàÂàÜÂâ≤Ôºâ ---
        
        // Èõ≤„ÅÆÊõ¥Êñ∞„Å®ÊèèÁîª
        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.update();
                cloud.draw(ctx);
            });
        }
        
        // È¢®„ÅÆÊõ¥Êñ∞
        function updateWindSystem() {
            if (isGameOver) return;
            wind.update(currentStage);
        }
        
        // „Éó„É¨„Ç§„É§„Éº„ÅÆÊõ¥Êñ∞Ôºà‰ΩçÁΩÆ„ÄÅÈÄüÂ∫¶„ÄÅÂ¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØÔºâ
        function updatePlayer() {
            const windForce = wind.getTotalWind();
            player.update(windForce, isGameOver, landing);
        }
        
        // ÁùÄÈô∏Âà§ÂÆö
        function checkLanding() {
            if (isGameOver) return;
            
            const result = player.checkLanding(landing);
            if (result === 'water') {
                isGameOver = true;
                setTimeout(() => { showResult('fail'); }, RESULT_DELAY);
            } else if (result === 'landed') {
                isGameOver = true;
                if (currentStage > bestStage) {
                    bestStage = currentStage;
                    document.getElementById('best').textContent = bestStage;
                }
                setTimeout(() => { showResult('success'); }, RESULT_DELAY);
            }
        }
        
        // ÊèèÁîªÂá¶ÁêÜ„ÅÆÈõÜÁ¥Ñ
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ËÉåÊôØË¶ÅÁ¥†„ÅÆÊèèÁîª
            updateClouds();
            drawSea();
            drawLanding();
            
            // „Çµ„É°„ÅÆÊèèÁîªÔºà„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞‰ªò„ÅçÔºâ
            try {
                drawSharks();
            } catch (e) {
                console.error("Shark draw failed", e);
            }
            
            // „Ç´„É©„Çπ„ÅÆÊõ¥Êñ∞„Å®ÊèèÁîª
            updateAndDrawKarasus();
            
            // „Éó„É¨„Ç§„É§„Éº„ÅÆÊèèÁîª
            drawPlayer();
            
            // UIÊõ¥Êñ∞
            updateWindIndicator();
        }
        
        // „É°„Ç§„É≥„Ç≤„Éº„É†„É´„Éº„Éó
        function gameLoop() {
            // Êõ¥Êñ∞Âá¶ÁêÜ
            updateWindSystem();
            updatePlayer();
            checkLanding();
            
            // ÊèèÁîªÂá¶ÁêÜ
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const actionBtn = document.getElementById('actionBtn');
        
        const setWind = (val) => { 
            if (!isGameOver) wind.setPlayerWind(val);
            startBgm(); 
        };
        
        // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÈáçË§áÁôªÈå≤„ÇíÈò≤„Åê
        function addBtnEvents(btn, val) {
            btn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                setWind(val); 
            }, { passive: false });
            
            btn.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                setWind(0); 
            }, { passive: false });

            // PCÁî®„Éû„Ç¶„ÇπÊìç‰Ωú
            btn.addEventListener('mousedown', () => setWind(val));
            btn.addEventListener('mouseup', () => setWind(0));
            btn.addEventListener('mouseleave', () => setWind(0));
        }
        
        addBtnEvents(leftBtn, WIND_STRENGTH_LEFT);
        addBtnEvents(rightBtn, WIND_STRENGTH_RIGHT);

        // A„Éú„Çø„É≥„Ç§„Éô„É≥„Éà
        actionBtn.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            doAction(); 
        }, { passive: false });
        
        actionBtn.addEventListener('mousedown', (e) => { 
            e.preventDefault(); 
            doAction(); 
        });
        
        window.addEventListener('keydown', (e) => {
            if (!isGameOver) {
                if (e.key === 'ArrowLeft') { wind.setPlayerWind(WIND_STRENGTH_LEFT); startBgm(); }
                if (e.key === 'ArrowRight') { wind.setPlayerWind(WIND_STRENGTH_RIGHT); startBgm(); }
                if (e.code === 'Space') { doAction(); } 
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') wind.setPlayerWind(0);
        });
        
        initStage(1);
        gameLoop();
    </script>
</body>
</html>
