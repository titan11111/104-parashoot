<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>„Éë„É©„Ç∑„É•„Éº„ÉàÁùÄÈô∏„Ç≤„Éº„É†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* ‰∏äË©∞„ÇÅ„Å´„Åô„Çã */
            width: 100%;
            height: 100vh; /* ÁîªÈù¢„ÅÑ„Å£„Å±„ÅÑ„Å´Âõ∫ÂÆö */
            height: 100dvh; /* „É¢„Éê„Ç§„É´„Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç¢„Éâ„É¨„Çπ„Éê„ÉºÂØæÁ≠ñ */
            padding: 10px;
            overflow: hidden; /* „Çπ„ÇØ„É≠„Éº„É´Á¶ÅÊ≠¢ */
            touch-action: none; /* „Çπ„ÇØ„É≠„Éº„É´„ÇÑ„Ç∫„Éº„É†„ÅÆ„Ç∏„Çß„Çπ„ÉÅ„É£„ÇíÁÑ°ÂäπÂåñ */
            user-select: none; /* Èï∑Êäº„Åó„Å´„Çà„Çã„ÉÜ„Ç≠„Çπ„ÉàÈÅ∏ÊäûÁ¶ÅÊ≠¢ */
            -webkit-user-select: none;
            -webkit-touch-callout: none; /* iOSÈï∑Êäº„Åó„É°„Éã„É•„ÉºÁ¶ÅÊ≠¢ */
        }
        
        h1 {
            color: #2C3E50;
            font-size: clamp(18px, 4vw, 24px); /* Â∞ë„ÅóÂ∞è„Åï„Åè„Åó„Å¶ÁîªÈù¢„ÇíÂ∫É„Åè‰Ωø„ÅÜ */
            margin: 5px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        
        .score-board {
            display: flex;
            gap: 15px;
            margin-bottom: 5px;
            font-size: clamp(12px, 3vw, 16px);
            color: #2C3E50;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .score-item {
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 12px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .game-container {
            position: relative;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            flex-grow: 1; /* ÂèØËÉΩ„Å™Èôê„ÇäÂ§ß„Åç„Åè */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 500px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        #gameCanvas {
            background: linear-gradient(to bottom, #87CEEB 0%, #B0E0E6 70%, #4682B4 100%);
            border: 2px solid #2C3E50;
            border-radius: 10px;
            display: block;
            /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çµ„Ç§„Ç∫Ë™øÊï¥: Á∏¶Ê®™ÊØî„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§„Ç≥„É≥„ÉÜ„Éä„Å´Âèé„ÇÅ„Çã */
            max-width: 100%;
            max-height: 100%;
            object-fit: contain; 
        }

        #gameOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            width: 85%;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal-title {
            font-size: 22px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .modal-msg {
            font-size: 15px;
            color: #555;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        .modal-btn {
            background: #2ECC71;
            color: white;
            border: none;
            padding: 12px 0;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            box-shadow: 0 3px 0 #27AE60;
        }
        .modal-btn:active {
            transform: translateY(3px);
            box-shadow: none;
        }
        .btn-retry { background: #E74C3C; box-shadow: 0 3px 0 #C0392B; }
        
        .wind-indicator {
            font-size: 16px;
            color: #2C3E50;
            font-weight: bold;
            min-height: 1.5em;
            text-align: center;
            margin-bottom: 5px;
            flex-shrink: 0;
        }
        
        .wind-bar {
            display: inline-block;
            font-family: monospace;
            letter-spacing: -2px;
        }

        /* --- „Ç≥„É≥„Éà„É≠„Éº„É©„Éº„Ç®„É™„Ç¢„ÅÆ„Éá„Ç∂„Ç§„É≥ --- */
        .controller-area {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 10px 20px 20px 20px; /* ‰∏ãÈÉ®„Å´‰ΩôÁôΩ */
            /* iOS„Çª„Éº„Éï„Ç®„É™„Ç¢ÂØæÂøúÔºàiPhone X‰ª•Èôç„ÅÆ‰∏ãÈÉ®„Éê„ÉºÂõûÈÅøÔºâ */
            padding-bottom: calc(20px + env(safe-area-inset-bottom)); 
            gap: 20px;
            flex-shrink: 0;
        }

        /* Â∑¶ÂÅ¥„ÅÆÁßªÂãï„Éú„Çø„É≥Áæ§ */
        .d-pad {
            display: flex;
            gap: 10px;
        }

        button.control-btn {
            background: linear-gradient(to bottom, #3498DB, #2980B9);
            color: white;
            border: none;
            width: 70px;
            height: 60px; /* Êäº„Åó„ÇÑ„Åô„ÅÑ„Çµ„Ç§„Ç∫ */
            font-size: 24px;
            font-weight: bold;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 0 4px 0 #1A5276;
            transition: transform 0.1s;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        button.control-btn:active {
            transform: translateY(4px);
            box-shadow: none;
            background: linear-gradient(to bottom, #2980B9, #21618C);
        }

        /* Âè≥ÂÅ¥„ÅÆA„Éú„Çø„É≥ */
        .action-btn-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #actionBtn {
            background: radial-gradient(circle at 30% 30%, #ff7f50, #ff4500);
            color: white;
            border: 4px solid #fff;
            width: 75px;
            height: 75px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: bold;
            box-shadow: 0 5px 10px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            touch-action: manipulation;
        }
        #actionBtn:active {
            transform: scale(0.95);
            background: radial-gradient(circle at 30% 30%, #ff6347, #cd3700);
        }

    </style>
</head>
<body>
    <h1>ü™Ç „Éë„É©„Ç∑„É•„Éº„ÉàÁùÄÈô∏„Ç≤„Éº„É†</h1>
    <div class="score-board">
        <div class="score-item">„Çπ„ÉÜ„Éº„Ç∏: <span id="stage">1</span> / 10</div>
        <div class="score-item">ÊúÄÈ´òË®òÈå≤: <span id="best">0</span></div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        
        <div id="gameOverlay">
            <div class="modal-content">
                <div id="modalTitle" class="modal-title"></div>
                <div id="modalMsg" class="modal-msg"></div>
                <button id="modalBtn" class="modal-btn">Ê¨°„Å∏</button>
            </div>
        </div>
    </div>

    <div class="wind-indicator" id="windIndicator">È¢®: Lv.0</div>
    
    <div class="controller-area">
        <div class="d-pad">
            <button id="leftBtn" class="control-btn">‚¨ÖÔ∏è</button>
            <button id="rightBtn" class="control-btn">‚û°Ô∏è</button>
        </div>
        
        <div class="action-btn-container">
            <button id="actionBtn">A</button>
        </div>
    </div>

    <audio id="bgm" src="audio/backgroundmugic.mp3" loop preload="auto"></audio>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // --- iOSÁî®„ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÊã°Â§ßÈò≤Ê≠¢ ---
        document.addEventListener('dblclick', function(event) {
            event.preventDefault();
        }, { passive: false });

        // „Éî„É≥„ÉÅ„Ç∫„Éº„É†Èò≤Ê≠¢
        document.addEventListener('touchmove', function(event) {
            if (event.scale !== 1) { 
                event.preventDefault(); 
            }
        }, { passive: false });
        
        // --- Web Audio API (SEÁîüÊàêÁî®) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSE(type) {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'float') {
                // „Åµ„Çè„Å£„Å®Èü≥
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);

            } else if (type === 'hit') {
                // Ë°ùÁ™ÅÈü≥
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);

            } else if (type === 'success') {
                // ÊàêÂäüÈü≥
                const notes = [523.25, 659.25, 783.99]; // C, E, G
                notes.forEach((freq, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'triangle';
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.frequency.value = freq;
                    const time = now + i * 0.1;
                    g.gain.setValueAtTime(0.2, time);
                    g.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
                    o.start(time);
                    o.stop(time + 0.4);
                });
            }
        }

        // --- BGMË®≠ÂÆö ---
        const bgm = document.getElementById('bgm');
        bgm.volume = 0.8; 
        let isBgmPlaying = false;

        function startBgm() {
            if (!isBgmPlaying) {
                bgm.play().then(() => {
                    isBgmPlaying = true;
                }).catch(e => {
                    console.log("BGM play waiting for interaction");
                });
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- SVGÁîªÂÉè„ÅÆÂÆöÁæ© ---
        const parachuteSVG = `
            <g transform="translate(250, 200)">
                <path d="M-150,0 A150,150 0 0,1 150,0" fill="none" stroke="#333" stroke-width="5"/>
                <path d="M-150,0 A150,150 0 0,1 -75,-129.9 L-50,-86.6 A100,100 0 0,0 -100,0 Z" fill="#E74C3C" stroke="#333" stroke-width="3"/>
                <path d="M-75,-129.9 A150,150 0 0,1 0,-150 L0,-100 A100,100 0 0,0 -50,-86.6 Z" fill="#E67E22" stroke="#333" stroke-width="3"/>
                <path d="M0,-150 A150,150 0 0,1 75,-129.9 L50,-86.6 A100,100 0 0,0 0,-100 Z" fill="#F1C40F" stroke="#333" stroke-width="3"/>
                <path d="M75,-129.9 A150,150 0 0,1 150,0 L100,0 A100,100 0 0,0 50,-86.6 Z" fill="#2ECC71" stroke="#333" stroke-width="3"/>
                <path d="M-100,0 A100,100 0 0,1 100,0" fill="#3498DB" stroke="#333" stroke-width="3"/>
            </g>
            <g stroke="#333" stroke-width="3">
                <line x1="100" y1="200" x2="200" y2="330" /> <line x1="400" y1="200" x2="300" y2="330" />
                <line x1="150" y1="200" x2="210" y2="330" /> <line x1="350" y1="200" x2="290" y2="330" />
                <line x1="200" y1="200" x2="220" y2="330" /> <line x1="300" y1="200" x2="280" y2="330" />
            </g>`;

        const svgNormalStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            ${parachuteSVG}
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="0" rx="50" ry="60" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <path d="M-30,-50 A40,40 0 0,1 30,-50" fill="#F1C40F" stroke="#333" stroke-width="3"/> 
                <g fill="#333"> 
                    <circle cx="-15" cy="-20" r="5"/> <circle cx="15" cy="-20" r="5"/>
                    <path d="M-25,-35 Q-15,-30 -5,-35" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M5,-35 Q15,-30 25,-35" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M-15,-5 Q0,-15 15,-5" fill="none" stroke="#333" stroke-width="2"/>
                </g>
                <path d="M-50,0 Q-70,-20 -60,-40" fill="none" stroke="#333" stroke-width="4"/>
                <path d="M50,0 Q70,-20 60,-40" fill="none" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        const svgPanicStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            ${parachuteSVG}
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="0" rx="50" ry="60" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <path d="M-30,-50 A40,40 0 0,1 30,-50" fill="#F1C40F" stroke="#333" stroke-width="3"/> 
                <g stroke="#333" stroke-width="3" fill="none">
                    <path d="M-25,-25 L-15,-20 L-25,-15"/>
                    <path d="M25,-25 L15,-20 L25,-15"/>
                    <circle cx="0" cy="10" r="10" fill="#333"/>
                    <path d="M35,-40 Q40,-50 45,-35" stroke="#3498DB" fill="#E0F7FA"/>
                    <path d="M-35,-40 Q-40,-50 -45,-35" stroke="#3498DB" fill="#E0F7FA"/>
                </g>
                <path d="M-45,-10 L-70,-40" stroke="#333" stroke-width="4"/>
                <path d="M45,-10 L70,-40" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        const svgLandedStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            <g transform="translate(250, 410) scale(1, 0.3)">
                <path d="M-150,0 A150,150 0 0,1 150,0 Z" fill="#BDC3C7" stroke="#333" stroke-width="5"/>
            </g>
            <g transform="translate(250, 380)">
                <ellipse cx="0" cy="10" rx="50" ry="50" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <g fill="#333"> 
                    <path d="M-20,-20 Q-15,-25 -10,-20" stroke="#333" stroke-width="3" fill="none"/>
                    <path d="M10,-20 Q15,-25 20,-20" stroke="#333" stroke-width="3" fill="none"/>
                    <path d="M-10,-5 Q0,10 10,-5" stroke="#333" stroke-width="2" fill="none"/>
                    <path d="M-50,20 L-70,0" stroke="#333" stroke-width="4"/>
                    <path d="M50,20 L70,0" stroke="#333" stroke-width="4"/>
                </g>
            </g>
        </svg>`;

        const svgWaterStr = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500">
            <g transform="translate(250, 380)">
                <path d="M-50,0 A50,60 0 0,1 50,0 L50,20 L-50,20 Z" fill="#FFE0B2" stroke="#333" stroke-width="3"/>
                <g fill="#333"> 
                    <circle cx="-15" cy="-20" r="7" fill="#fff"/> <circle cx="-15" cy="-20" r="2"/>
                    <circle cx="15" cy="-20" r="7" fill="#fff"/> <circle cx="15" cy="-20" r="2"/>
                    <path d="M-10,0 Q0,-5 10,0 Q5,5 -5,5 Z" fill="none" stroke="#333" stroke-width="2"/>
                    <path d="M-20,-15 L-18,-12 M20,-15 L18,-12" stroke="#3498DB" stroke-width="2"/>
                </g>
                <path d="M-50,0 Q-70,-30 -80,-10" fill="none" stroke="#333" stroke-width="4"/>
                <path d="M50,0 Q70,-30 80,-10" fill="none" stroke="#333" stroke-width="4"/>
            </g>
        </svg>`;

        function createImg(svgStr) {
            const img = new Image();
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgStr);
            return img;
        }

        const imgNormal = createImg(svgNormalStr);
        const imgPanic = createImg(svgPanicStr);
        const imgLanded = createImg(svgLandedStr);
        const imgWater = createImg(svgWaterStr);
        
        let sharkLoaded = false;
        const imgShark = new Image();
        imgShark.onload = function() { sharkLoaded = true; };
        imgShark.onerror = function() { sharkLoaded = false; };
        imgShark.src = 'shark.png'; 

        let karasuLoaded = false;
        const imgKarasu = new Image();
        imgKarasu.onload = function() { karasuLoaded = true; };
        imgKarasu.onerror = function() { karasuLoaded = false; };
        imgKarasu.src = 'karasu.png';

        // --- „Ç≤„Éº„É†Â§âÊï∞ ---
        
        function resizeCanvas() {
            // „Ç≤„Éº„É†„Ç≥„É≥„ÉÜ„Éä„ÅÆ„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË™øÊï¥
            const container = document.querySelector('.game-container');
            const aspect = 400 / 600;
            
            // „Ç≥„É≥„ÉÜ„Éä„ÅÆÂπÖ„Å®È´ò„Åï„Åã„ÇâÊúÄÈÅ©„Å™„Çµ„Ç§„Ç∫„ÇíË®àÁÆó
            let w = container.clientWidth;
            let h = container.clientHeight;
            
            if (w / h > aspect) {
                // Ê®™Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÄÅÈ´ò„Åï„Å´Âêà„Çè„Åõ„Çã
                w = h * aspect;
            } else {
                // Á∏¶Èï∑„Åô„Åé„ÇãÂ†¥Âêà„ÄÅÂπÖ„Å´Âêà„Çè„Åõ„Çã
                h = w / aspect;
            }
            
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
        }
        window.addEventListener('resize', resizeCanvas);
        // ÂàùÊúüÂåñÊôÇ„Å´„ÇÇÂëº„Å∂ÔºàDOMÊèèÁîªÂæÖ„Å°Ôºâ
        setTimeout(resizeCanvas, 100);
        
        let currentStage = 1;
        let bestStage = 0;
        
        // „Éë„É©„É°„Éº„Çø
        const BASE_GRAVITY_SPEED = 0.85; 

        let player = {
            x: 200,
            y: 50,
            vx: 0,
            vy: BASE_GRAVITY_SPEED,
            state: 'falling',
            mood: 'normal',
            radius: 30 
        };
        
        let wind = 0;
        let naturalWind = 0;
        let targetNaturalWind = 0;
        let windChangeTimer = 0;
        let isGameOver = false;
        let clouds = [];
        let karasus = []; 
        
        let landing = { start: 140, end: 260, y: 550 };
        
        function initClouds() {
            clouds = [];
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * 400,
                    y: Math.random() * 400,
                    size: 20 + Math.random() * 30,
                    speed: 0.3 + Math.random() * 0.5
                });
            }
        }

        function initKarasus(stage) {
            karasus = [];
            if (stage < 3) return; 

            const count = (stage - 2) * 2;
            
            for (let i = 0; i < count; i++) {
                const startLeft = Math.random() < 0.5;
                const speedBase = (1.5 + Math.random() * 2.0) * 0.2; 
                
                karasus.push({
                    x: startLeft ? -100 - Math.random() * 100 : canvas.width + 100 + Math.random() * 100,
                    y: 50 + Math.random() * 300, 
                    vx: startLeft ? speedBase : -speedBase, 
                    vyBase: Math.random() * 0.5, 
                    vyFreq: 0.05 + Math.random() * 0.05, 
                    timer: Math.random() * 100,
                    width: 120,
                    height: 90,
                    motionType: Math.floor(Math.random() * 3)
                });
            }
        }
        
        initClouds();
        
        const overlay = document.getElementById('gameOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMsg = document.getElementById('modalMsg');
        const modalBtn = document.getElementById('modalBtn');

        function hideOverlay() {
            overlay.style.display = 'none';
        }

        function showResult(type) {
            overlay.style.display = 'flex';
            modalBtn.className = 'modal-btn';

            if (type === 'success' && currentStage >= 10) {
                type = 'gameclear';
            }

            if (type === 'success') {
                playSE('success'); 
                modalTitle.textContent = `„Çπ„ÉÜ„Éº„Ç∏ ${currentStage} „ÇØ„É™„Ç¢ÔºÅüéâ`;
                modalTitle.style.color = '#2ECC71';
                modalMsg.textContent = '„ÅäË¶ã‰∫ã„Åß„ÅôÔºÅ\nÊ¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏ÈÄ≤„Åø„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = 'Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏';
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(currentStage + 1);
                    gameLoop();
                };
            } else if (type === 'gameclear') {
                playSE('success'); 
                modalTitle.textContent = `ÂÖ®„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢ÔºÅüéä`;
                modalTitle.style.color = '#F1C40F';
                modalMsg.textContent = '„ÅÇ„Å™„Åü„ÅØÊúÄÈ´ò„ÅÆ„Éë„Ç§„É≠„ÉÉ„Éà„Åß„ÅôÔºÅ\nÊúÄÂàù„Åã„ÇâÈÅä„Å≥„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = '„ÅØ„Åò„ÇÅ„Åã„Çâ';
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(1);
                    gameLoop();
                };
            } else {
                playSE('hit'); 
                modalTitle.textContent = `Â§±Êïó... üò±`;
                modalTitle.style.color = '#E74C3C';
                modalMsg.textContent = 'Ë°ùÁ™Å„Åó„Å¶„Åó„Åæ„ÅÑ„Åæ„Åó„Åü...\n„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶„Åó„Åæ„Åô„ÅãÔºü';
                
                modalBtn.textContent = '„É™„Éà„É©„Ç§';
                modalBtn.classList.add('btn-retry');
                modalBtn.onclick = () => {
                    hideOverlay();
                    initStage(currentStage);
                    gameLoop();
                };
            }
        }

        function initStage(stage) {
            currentStage = stage;
            document.getElementById('stage').textContent = stage;
            hideOverlay();
            
            player.x = 200;
            player.y = 50;
            player.vx = 0;
            player.vy = BASE_GRAVITY_SPEED;
            player.state = 'falling';
            player.mood = 'normal';
            
            const baseWidth = 120;
            const reduction = (stage - 1) * 3;
            const newWidth = Math.max(20, baseWidth - reduction);
            const center = 200;
            landing.start = center - newWidth / 2;
            landing.end = center + newWidth / 2;
            
            wind = 0;
            naturalWind = 0;
            targetNaturalWind = 0;
            windChangeTimer = 0;
            isGameOver = false;
            
            initClouds();
            initKarasus(stage); 
            startBgm(); 
            resizeCanvas(); // „É™„Éà„É©„Ç§ÊôÇ„ÇÇ„Çµ„Ç§„Ç∫Á¢∫Ë™ç
        }
        
        function drawCloud(x, y, size) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.arc(x + size * 0.6, y, size * 0.8, 0, Math.PI * 2);
            ctx.arc(x - size * 0.6, y, size * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawSea() {
            ctx.fillStyle = '#1E90FF';
            ctx.fillRect(0, landing.y, canvas.width, canvas.height - landing.y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                for (let x = 0; x <= canvas.width; x += 20) {
                    const y = landing.y + 10 + i * 15 + Math.sin(x * 0.05 + Date.now() * 0.003) * 5;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }
        
        function drawLanding() {
            const width = landing.end - landing.start;
            const centerX = (landing.start + landing.end) / 2;
            const islandHeight = 30;

            ctx.fillStyle = '#E5C687';
            ctx.beginPath();
            ctx.ellipse(centerX, landing.y, width / 2 + 10, islandHeight, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#D4B06F';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = '#2ECC71';
            ctx.beginPath();
            ctx.ellipse(centerX, landing.y - 2, width / 2, islandHeight / 1.5, 0, Math.PI, 0); 
            ctx.fill();

            if (width > 30) {
                const treeX = centerX + width / 4;
                const treeY = landing.y - 5;
                ctx.strokeStyle = '#8D6E63';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(treeX, treeY);
                ctx.quadraticCurveTo(treeX + 5, treeY - 15, treeX - 5, treeY - 30);
                ctx.stroke();

                ctx.fillStyle = '#228B22';
                for(let i=0; i<3; i++) {
                    ctx.beginPath();
                    const angle = (i * 120) * Math.PI / 180;
                    const lx = treeX - 5 + Math.cos(angle) * 15;
                    const ly = treeY - 30 + Math.sin(angle) * 10;
                    ctx.ellipse(lx, ly, 8, 4, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawSharks() {
            const sharkWidth = 300;  
            const sharkHeight = 175; 
            const yPos = landing.y - 80; 
            const useImage = sharkLoaded;

            const leftSharkCenterX = landing.start / 2; 
            const leftSharkDrawX = leftSharkCenterX - (sharkWidth / 2);

            if (useImage) {
                ctx.drawImage(imgShark, leftSharkDrawX, yPos, sharkWidth, sharkHeight);
            } else {
                ctx.font = '200px Arial';
                ctx.fillText('ü¶à', leftSharkCenterX - 100, yPos + 150);
            }
            
            const rightSharkCenterX = (landing.end + canvas.width) / 2;
            
            if (useImage) {
                ctx.save();
                ctx.translate(rightSharkCenterX, yPos);
                ctx.scale(-1, 1);
                ctx.drawImage(imgShark, -sharkWidth / 2, 0, sharkWidth, sharkHeight);
                ctx.restore();
            } else {
                ctx.font = '200px Arial';
                ctx.fillText('ü¶à', rightSharkCenterX - 100, yPos + 150);
            }
        }
        
        function updateAndDrawKarasus() {
            karasus.forEach(k => {
                if (!isGameOver) {
                    k.timer += 0.1;
                    k.x += k.vx;
                    
                    if (k.motionType === 0) {
                        k.y += Math.sin(k.timer) * 0.5;
                    } else if (k.motionType === 1) {
                        k.y += Math.sin(k.timer * 0.5) * 2.0;
                    } else {
                        k.y += Math.sin(k.timer * 3.0) * 1.5;
                    }

                    if (k.vx > 0 && k.x > canvas.width + 100) {
                        k.x = -100;
                        k.y = 50 + Math.random() * 300;
                    }
                    else if (k.vx < 0 && k.x < -100) {
                        k.x = canvas.width + 100;
                        k.y = 50 + Math.random() * 300;
                    }

                    const kCenterX = k.x + k.width / 2;
                    const kCenterY = k.y + k.height / 2;
                    const dx = player.x - kCenterX;
                    const dy = player.y - kCenterY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 55) {
                        isGameOver = true;
                        player.state = 'falling'; 
                        setTimeout(() => { showResult('fail'); }, 500);
                    }
                }

                if (karasuLoaded) {
                    ctx.save();
                    ctx.translate(k.x + k.width/2, k.y + k.height/2);
                    
                    if (k.vx < 0) {
                        ctx.scale(-1, 1); 
                    } else {
                        ctx.scale(1, 1);
                    }
                    
                    ctx.drawImage(imgKarasu, -k.width/2, -k.height/2, k.width, k.height);
                    ctx.restore();
                } else {
                    ctx.fillStyle = 'black';
                    ctx.font = '60px Arial';
                    ctx.fillText('ü¶Ö', k.x, k.y + 40);
                }
            });
        }

        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            const size = 100;
            
            if (player.state === 'falling') {
                const sway = Math.sin(Date.now() / 300) * 0.05;
                ctx.rotate(sway);

                const isWindy = Math.abs(wind) > 0.1;
                const isNearGround = player.y > 400;
                const safeMargin = 20; 
                const isSafe = player.x >= landing.start - safeMargin && player.x <= landing.end + safeMargin;
                
                let currentImg = imgNormal;
                if (isWindy || (isNearGround && !isSafe)) {
                    currentImg = imgPanic; 
                    const panicShake = Math.sin(Date.now() / 50) * 0.05;
                    ctx.rotate(panicShake);
                }
                ctx.drawImage(currentImg, -size/2, -size/2 - 20, size, size);

            } else if (player.state === 'water') {
                const bob = Math.sin(Date.now() / 200) * 3;
                ctx.translate(0, bob);
                ctx.drawImage(imgWater, -size/2, -size/2 + 20, size, size);

            } else if (player.state === 'landed') {
                ctx.drawImage(imgLanded, -size/2, -size/2 + 10, size, size);
            }
            
            ctx.restore();
        }
        
        function updateWindIndicator() {
            const windIndicator = document.getElementById('windIndicator');
            const totalWind = naturalWind + wind;
            const maxWind = 0.6;
            
            const windMag = Math.abs(totalWind);
            let level = Math.floor((windMag / maxWind) * 10);
            if (level > 10) level = 10;
            if (windMag > 0 && level === 0) level = 1;
            if (windMag < 0.05) level = 0;

            let text = "";
            let color = "#2C3E50";

            if (level === 0) {
                text = "È¢®: ÁÑ°È¢® (Lv.0)";
            } else {
                const arrow = totalWind < 0 ? "‚óÄ" : "‚ñ∂";
                const bars = arrow.repeat(level);
                if (totalWind < 0) {
                    text = `È¢®: <span class="wind-bar">${bars}</span> Lv.${level}`;
                    color = "#3498DB";
                } else {
                    text = `È¢®: Lv.${level} <span class="wind-bar">${bars}</span>`;
                    color = "#E67E22";
                }
            }
            windIndicator.innerHTML = text;
            windIndicator.style.color = color;
        }
        
        // A„Éú„Çø„É≥„Ç¢„ÇØ„Ç∑„Éß„É≥
        function doAction() {
            if (!isGameOver && player.state === 'falling') {
                // ‰∏ÄÁû¨Ê∏õÈÄü
                player.vy = -0.5;
                playSE('float'); 
                startBgm();
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > canvas.width + cloud.size) {
                    cloud.x = -cloud.size;
                    cloud.y = Math.random() * 400;
                }
                drawCloud(cloud.x, cloud.y, cloud.size);
            });
            
            drawSea();
            drawLanding();
            
            try {
                drawSharks();
            } catch (e) {
                console.error("Shark draw failed", e);
            }
            
            updateAndDrawKarasus();
            
            if (!isGameOver) {
                windChangeTimer++;
                if (windChangeTimer > 60) {
                    windChangeTimer = 0;
                    const windStrength = 0.1 + (currentStage - 1) * 0.02;
                    targetNaturalWind = (Math.random() - 0.5) * windStrength;
                }
                naturalWind += (targetNaturalWind - naturalWind) * 0.05;

                if (player.vy < BASE_GRAVITY_SPEED) {
                    player.vy += 0.05;
                } else {
                    player.vy = BASE_GRAVITY_SPEED;
                }

                player.vx += wind + naturalWind;
                player.vx *= 0.95;
                player.x += player.vx;
                player.y += player.vy;
                
                if (player.x < 15) { player.x = 15; player.vx = 0; }
                if (player.x > canvas.width - 15) { player.x = canvas.width - 15; player.vx = 0; }
                
                if (player.y >= landing.y) {
                    isGameOver = true;
                    player.state = 'water';
                    player.y = landing.y;
                    player.vx = 0; player.vy = 0;
                    setTimeout(() => { showResult('fail'); }, 500);
                }
                else {
                    const groundLevel = landing.y - 15; 
                    if (player.y >= groundLevel) {
                        const safeMargin = 15; 
                        const isSafe = (player.x >= landing.start - safeMargin && player.x <= landing.end + safeMargin);
                        if (isSafe) {
                            isGameOver = true;
                            player.state = 'landed';
                            player.y = landing.y - 10;
                            player.vx = 0; player.vy = 0;
                            if (currentStage > bestStage) {
                                bestStage = currentStage;
                                document.getElementById('best').textContent = bestStage;
                            }
                            setTimeout(() => { showResult('success'); }, 500); 
                        }
                    }
                }
            } else {
                if (player.state === 'landed') {
                    player.y = landing.y - 10;
                    player.vx = 0;
                }
                if (player.state === 'water') {
                    player.y = landing.y;
                    player.vx = 0;
                }
            }
            
            drawPlayer();
            updateWindIndicator();
            
            requestAnimationFrame(gameLoop);
        }
        
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const actionBtn = document.getElementById('actionBtn');
        
        const setWind = (val) => { 
            if (!isGameOver) wind = val;
            startBgm(); 
        };
        
        // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÈáçË§áÁôªÈå≤„ÇíÈò≤„Åê
        function addBtnEvents(btn, val) {
            btn.addEventListener('touchstart', (e) => { 
                e.preventDefault(); 
                setWind(val); 
            }, { passive: false });
            
            btn.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                setWind(0); 
            }, { passive: false });

            // PCÁî®„Éû„Ç¶„ÇπÊìç‰Ωú
            btn.addEventListener('mousedown', () => setWind(val));
            btn.addEventListener('mouseup', () => setWind(0));
            btn.addEventListener('mouseleave', () => setWind(0));
        }
        
        addBtnEvents(leftBtn, -0.3);
        addBtnEvents(rightBtn, 0.3);

        // A„Éú„Çø„É≥„Ç§„Éô„É≥„Éà
        actionBtn.addEventListener('touchstart', (e) => { 
            e.preventDefault(); 
            doAction(); 
        }, { passive: false });
        
        actionBtn.addEventListener('mousedown', (e) => { 
            e.preventDefault(); 
            doAction(); 
        });
        
        window.addEventListener('keydown', (e) => {
            if (!isGameOver) {
                if (e.key === 'ArrowLeft') { wind = -0.3; startBgm(); }
                if (e.key === 'ArrowRight') { wind = 0.3; startBgm(); }
                if (e.code === 'Space') { doAction(); } 
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') wind = 0;
        });
        
        initStage(1);
        gameLoop();
    </script>
</body>
</html>
